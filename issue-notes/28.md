# issue 直近24時間でuser commitがあるかどうか、のチェックを、workflowのjobs先頭に新規jobを追加して実施し、本体jobの先頭にneedsを書く #28
[issues #28](https://github.com/cat2151/github-actions/issues/28)

# これまでの課題は？
- これまでは各workflow内の終盤のscriptにバラバラに実装されていたので、
    - ムダにcheckout等、各種処理が走っていた

# 対策案は？
- 直近24時間でuser commitがあるかどうか、
    - のチェックを、
        - workflowのjobs先頭に新規jobを追加して実施し、
            - 本体jobの先頭にneedsを書く
- この対策で、各workflow先頭にこれを書くだけでよくなり、エコになる想定

# ChatGPTに生成させた
## 呼び出し元のサンプル
- 実際には、共通workflowのjobsの先頭付近を、このサンプルを参考に書き換えるイメージ
```
jobs:
  check_recent_human_commit:
    uses: ./.github/workflows/check-recent-human-commit.yml

  build:
    needs: check_recent_human_commit
    if: needs.check_recent_human_commit.outputs.has_recent_human_commit == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Run build
        run: echo "Building because there is a recent human commit!"
```
## 共通ワークフロー側の案
- シンプルにmailのみを条件とし、mailも1種類のみに明示する
```
name: "Check recent human commit"

on:
  workflow_call:

jobs:
  check-recent-human-commit:
    runs-on: ubuntu-latest
    outputs:
      has_recent_human_commit: ${{ steps.check.outputs.has_recent_human_commit }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Check recent human commit
        id: check
        run: |
          set -e

          HAS_HUMAN=false

          while IFS=$'\x01' read -r HASH NAME EMAIL SUBJECT; do
            SUBJECT="${SUBJECT%$'\x02'}"

            if [[ ! "$EMAIL" =~ ^41898282\+github-actions\[bot\]@users\.noreply\.github\.com$ ]]; then
              echo "HUMAN: Commit $HASH | Author: $NAME <$EMAIL> | Message: $SUBJECT"
              HAS_HUMAN=true
              break
            else
              echo "BOT: Commit $HASH | Author: $NAME <$EMAIL> | Message: $SUBJECT"
            fi
          done <<< "$(git log --since="24 hours ago" --pretty=format:'%H%x01%an%x01%ae%x01%s%x02')"

          if [ "$HAS_HUMAN" = true ]; then
            echo "Found recent human commit."
            echo "has_recent_human_commit=true" >> $GITHUB_OUTPUT
          else
            echo "No human commits in last 24h."
            echo "has_recent_human_commit=false" >> $GITHUB_OUTPUT
```
## 備忘
- 上記はChatGPTに生成させ、それをレビューさせて改善させる、のサイクルで生成した。
    - 一発で生成はできなかった
    - ChatGPTが自分で生成したものに対して自己レビューでミスや改善点が多発していた
        - ブレも発生し、二転三転気味でもあり、
            - ハルシネーションに近い低品質状態だと感じた
                - これは経験則からの感覚的なもの
    - 生成の品質が低い、ということ
        - LLMはまだ学習不足、github-actions workflow yml の学習不足である、と解釈する
        - shell scriptの生成品質も低いかも。
            - もともとshell scriptで複雑なlogicを書くとtest costが高い、なぜなら読みづらいから。
                - なのでロジックをcjs側に切り出したほうが全体最適の観点からよりよい、と考える

# どうする？
- shell scriptはやめて、cjsでlogicを担当させる。
  - 現状のshell scriptを改めて見直すと、これはcjs側にしたほうがよい、と感覚的に、経験則で、わかる。
- logicをcjs側に切り出す。実際、既存でgitの24hチェックをcjs側でやっている実績がある。そこのロジックを参考にする。
- 今のmdの仕様をもとに、ymlとcjsを生成させる。
- 生成させた。ChatGPTに投げた
- 人力でいくつか変更したり、ChatGPTに投げて修正させるサイクルを回したりした
- testする

# バグ
- 結果、バグがあったのでagentにlogを投げ、修正させ、人力修正し、agentにセルフレビューさせ、のサイクルを回した
- testする
- 結果、callgraphで、エラーなくhumanを検知したが、callgraphが呼ばれない、というバグが発生
- ひとまずagentの提案したcodeを切り分けのため試す、バグ状況は変わらない想定
- 結果、バグ状況は変わらず
- 対策、trueのlogをagentに投げて、callgraphが呼ばれないことを伝え、可視化を実装させた
- testする
- 結果、バグ状況は変わらず
- 対策、logをagentに投げて、callgraphが呼ばれないことを伝え、さらに可視化を実装させた
- testする
- 結果、バグ状況は変わらず
- 対策、logをagentに投げて、callgraphが呼ばれないことを伝え、さらに可視化を実装させた
- testする
- 結果、バグ状況は変わらず
- 対策、logをagentに投げて、callgraphが呼ばれないことを伝えた
- ここで、根本的にymlのworkflow記述が間違っていることが判明
  - agentが最初にcode生成したときから根本的なバグが仕込まれていたということ。
    - agentの学習不足。github-actionsのworkflowの学習不足。
- そこをagentに修正させ、test greenとなった

# closeとする
